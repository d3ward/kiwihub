(()=>{var __webpack_modules__={551:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./js/components/prism.min.js\nvar prism_min = __webpack_require__(784);\n;// ../node_modules/a11y-dialog/dist/a11y-dialog.esm.js\nconst not = {\n  inert: \':not([inert]):not([inert] *)\',\n  negTabIndex: \':not([tabindex^="-"])\',\n  disabled: \':not(:disabled)\',\n};\n\nvar focusableSelectors = [\n  `a[href]${not.inert}${not.negTabIndex}`,\n  `area[href]${not.inert}${not.negTabIndex}`,\n  `input:not([type="hidden"]):not([type="radio"])${not.inert}${not.negTabIndex}${not.disabled}`,\n  `input[type="radio"]${not.inert}${not.negTabIndex}${not.disabled}`,\n  `select${not.inert}${not.negTabIndex}${not.disabled}`,\n  `textarea${not.inert}${not.negTabIndex}${not.disabled}`,\n  `button${not.inert}${not.negTabIndex}${not.disabled}`,\n  `details${not.inert} > summary:first-of-type${not.negTabIndex}`,\n  // Discard until Firefox supports `:has()`\n  // See: https://github.com/KittyGiraudel/focusable-selectors/issues/12\n  // `details:not(:has(> summary))${not.inert}${not.negTabIndex}`,\n  `iframe${not.inert}${not.negTabIndex}`,\n  `audio[controls]${not.inert}${not.negTabIndex}`,\n  `video[controls]${not.inert}${not.negTabIndex}`,\n  `[contenteditable]${not.inert}${not.negTabIndex}`,\n  `[tabindex]${not.inert}${not.negTabIndex}`,\n];\n\n/**\n * Set the focus to the first element with `autofocus` with the element or the\n * element itself.\n */\nfunction a11y_dialog_esm_focus(el) {\n    (el.querySelector(\'[autofocus]\') || el).focus();\n}\n/**\n * Get the first and last focusable elements within a given element.\n */\nfunction getFocusableEdges(el) {\n    // Check for a focusable element within the subtree of the given element.\n    const firstEl = findFocusableEl(el, true);\n    // Only if we find the first element do we need to look for the last one. If\n    // there’s no last element, we set `lastEl` as a reference to `firstEl` so\n    // that the returned array is still always of length 2.\n    const lastEl = firstEl ? findFocusableEl(el, false) || firstEl : null;\n    return [firstEl, lastEl];\n}\n/**\n * Find the first focusable element inside the given element if `forward` is\n * truthy or the last focusable element otherwise.\n */\nfunction findFocusableEl(el, forward) {\n    // If we’re walking forward, check if this element is focusable, and return it\n    // immediately if it is.\n    if (forward && isFocusable(el))\n        return el;\n    // We should only search the subtree of this element if it can have focusable\n    // children.\n    if (canHaveFocusableChildren(el)) {\n        // Start walking the DOM tree, looking for focusable elements.\n        // Case 1: If this element has a shadow root, search it recursively.\n        if (el.shadowRoot) {\n            // Descend into this subtree.\n            let next = getNextChildEl(el.shadowRoot, forward);\n            // Traverse the siblings, searching the subtree of each one for focusable\n            // elements.\n            while (next) {\n                const focusableEl = findFocusableEl(next, forward);\n                if (focusableEl)\n                    return focusableEl;\n                next = getNextSiblingEl(next, forward);\n            }\n        }\n        // Case 2: If this element is a slot for a Custom Element, search its\n        // assigned elements recursively.\n        else if (el.localName === \'slot\') {\n            const assignedElements = el.assignedElements({\n                flatten: true,\n            });\n            if (!forward)\n                assignedElements.reverse();\n            for (const assignedElement of assignedElements) {\n                const focusableEl = findFocusableEl(assignedElement, forward);\n                if (focusableEl)\n                    return focusableEl;\n            }\n        }\n        // Case 3: this is a regular Light DOM element. Search its subtree.\n        else {\n            // Descend into this subtree.\n            let next = getNextChildEl(el, forward);\n            // Traverse siblings, searching the subtree of each one\n            // for focusable elements.\n            while (next) {\n                const focusableEl = findFocusableEl(next, forward);\n                if (focusableEl)\n                    return focusableEl;\n                next = getNextSiblingEl(next, forward);\n            }\n        }\n    }\n    // If we’re walking backward, we want to check the element’s entire subtree\n    // before checking the element itself. If this element is focusable, return\n    // it.\n    if (!forward && isFocusable(el))\n        return el;\n    return null;\n}\nfunction getNextChildEl(el, forward) {\n    return forward ? el.firstElementChild : el.lastElementChild;\n}\nfunction getNextSiblingEl(el, forward) {\n    return forward ? el.nextElementSibling : el.previousElementSibling;\n}\n/**\n * Determine if an element is hidden from the user.\n */\nconst isHidden = (el) => {\n    // Browsers hide all non-<summary> descendants of closed <details> elements\n    // from user interaction, but those non-<summary> elements may still match our\n    // focusable-selectors and may still have dimensions, so we need a special\n    // case to ignore them.\n    if (el.matches(\'details:not([open]) *\') &&\n        !el.matches(\'details>summary:first-of-type\'))\n        return true;\n    // If this element has no painted dimensions, it\'s hidden.\n    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n};\n/**\n * Determine if an element is focusable and has user-visible painted dimensions.\n */\nconst isFocusable = (el) => {\n    // A shadow host that delegates focus will never directly receive focus,\n    // even with `tabindex=0`. Consider our <fancy-button> custom element, which\n    // delegates focus to its shadow button:\n    //\n    // <fancy-button tabindex="0">\n    //  #shadow-root\n    //  <button><slot></slot></button>\n    // </fancy-button>\n    //\n    // The browser acts as as if there is only one focusable element – the shadow\n    // button. Our library should behave the same way.\n    if (el.shadowRoot?.delegatesFocus)\n        return false;\n    return el.matches(focusableSelectors.join(\',\')) && !isHidden(el);\n};\n/**\n * Determine if an element can have focusable children. Useful for bailing out\n * early when walking the DOM tree.\n * @example\n * This div is inert, so none of its children can be focused, even though they\n * meet our criteria for what is focusable. Once we check the div, we can skip\n * the rest of the subtree.\n * ```html\n * <div inert>\n *   <button>Button</button>\n *   <a href="#">Link</a>\n * </div>\n * ```\n */\nfunction canHaveFocusableChildren(el) {\n    // The browser will never send focus into a Shadow DOM if the host element\n    // has a negative tabindex. This applies to both slotted Light DOM Shadow DOM\n    // children\n    if (el.shadowRoot && el.getAttribute(\'tabindex\') === \'-1\')\n        return false;\n    // Elemments matching this selector are either hidden entirely from the user,\n    // or are visible but unavailable for interaction. Their descentants can never\n    // receive focus.\n    return !el.matches(\':disabled,[hidden],[inert]\');\n}\n/**\n * Get the active element, accounting for Shadow DOM subtrees.\n * @author Cory LaViska\n * @see: https://www.abeautifulsite.net/posts/finding-the-active-element-in-a-shadow-root/\n */\nfunction getActiveEl(root = document) {\n    const activeEl = root.activeElement;\n    if (!activeEl)\n        return null;\n    // If there’s a shadow root, recursively find the active element within it.\n    // If the recursive call returns null, return the active element\n    // of the top-level Document.\n    if (activeEl.shadowRoot)\n        return getActiveEl(activeEl.shadowRoot) || document.activeElement;\n    // If not, we can just return the active element\n    return activeEl;\n}\n/**\n * Trap the focus inside the given element\n */\nfunction trapTabKey(el, event) {\n    const [firstFocusableEl, lastFocusableEl] = getFocusableEdges(el);\n    // If there are no focusable children in the dialog, prevent the user from\n    // tabbing out of it\n    if (!firstFocusableEl)\n        return event.preventDefault();\n    const activeEl = getActiveEl();\n    // If the SHIFT key is pressed while tabbing (moving backwards) and the\n    // currently focused item is the first one, move the focus to the last\n    // focusable item from the dialog element\n    if (event.shiftKey && activeEl === firstFocusableEl) {\n        // @ts-ignore: we know that `lastFocusableEl` is not null here\n        lastFocusableEl.focus();\n        event.preventDefault();\n    }\n    // If the SHIFT key is not pressed (moving forwards) and the currently focused\n    // item is the last one, move the focus to the first focusable item from the\n    // dialog element\n    else if (!event.shiftKey && activeEl === lastFocusableEl) {\n        firstFocusableEl.focus();\n        event.preventDefault();\n    }\n}\n/**\n * Find the closest element to the given element matching the given selector,\n * accounting for Shadow DOM subtrees.\n * @author Louis St-Amour\n * @see: https://stackoverflow.com/a/56105394\n */\nfunction closest(selector, base) {\n    function from(el) {\n        if (!el || el === document || el === window)\n            return null;\n        if (el.assignedSlot)\n            el = el.assignedSlot;\n        return (el.closest(selector) ||\n            from(el.getRootNode().host));\n    }\n    return from(base);\n}\n\nconst SCOPE = \'data-a11y-dialog\';\nclass A11yDialog {\n    $el;\n    id;\n    previouslyFocused;\n    shown;\n    constructor(element) {\n        this.$el = element;\n        this.id = this.$el.getAttribute(SCOPE) || this.$el.id;\n        this.previouslyFocused = null;\n        this.shown = false;\n        this.maintainFocus = this.maintainFocus.bind(this);\n        this.bindKeypress = this.bindKeypress.bind(this);\n        this.handleTriggerClicks = this.handleTriggerClicks.bind(this);\n        this.show = this.show.bind(this);\n        this.hide = this.hide.bind(this);\n        this.$el.setAttribute(\'aria-hidden\', \'true\');\n        this.$el.setAttribute(\'aria-modal\', \'true\');\n        this.$el.setAttribute(\'tabindex\', \'-1\');\n        if (!this.$el.hasAttribute(\'role\')) {\n            this.$el.setAttribute(\'role\', \'dialog\');\n        }\n        document.addEventListener(\'click\', this.handleTriggerClicks, true);\n    }\n    /**\n     * Destroy the current instance (after making sure the dialog has been hidden)\n     * and remove all associated listeners from dialog openers and closers\n     */\n    destroy() {\n        // Dispatch a `destroy` event\n        const destroyEvent = this.fire(\'destroy\');\n        // If the event was prevented, do not continue with the normal behavior\n        if (destroyEvent.defaultPrevented)\n            return this;\n        // Hide the dialog to avoid destroying an open instance\n        this.hide();\n        // Remove the click event delegates for our openers and closers\n        document.removeEventListener(\'click\', this.handleTriggerClicks, true);\n        // Clone and replace the dialog element to prevent memory leaks caused by\n        // event listeners that the author might not have cleaned up.\n        this.$el.replaceWith(this.$el.cloneNode(true));\n        return this;\n    }\n    /**\n     * Show the dialog element, trap the current focus within it, listen for some\n     * specific key presses and fire all registered callbacks for `show` event\n     */\n    show(event) {\n        // If the dialog is already open, abort\n        if (this.shown)\n            return this;\n        // Dispatch a `show` event\n        const showEvent = this.fire(\'show\', event);\n        // If the event was prevented, do not continue with the normal behavior\n        if (showEvent.defaultPrevented)\n            return this;\n        // Keep a reference to the currently focused element to be able to restore\n        // it later\n        this.shown = true;\n        this.$el.removeAttribute(\'aria-hidden\');\n        this.previouslyFocused = getActiveEl();\n        // Due to a long lasting bug in Safari, clicking an interactive element\n        // (like a <button>) does *not* move the focus to that element, which means\n        // `document.activeElement` is whatever element is currently focused (like\n        // an <input>), or the <body> element otherwise. We can work around that\n        // problem by checking whether the focused element is the <body>, and if it,\n        // store the click event target.\n        // See: https://bugs.webkit.org/show_bug.cgi?id=22261\n        if (this.previouslyFocused?.tagName === \'BODY\' && event?.target) {\n            this.previouslyFocused = event.target;\n        }\n        // Set the focus to the dialog element\n        // See: https://github.com/KittyGiraudel/a11y-dialog/pull/583\n        if (event?.type === \'focus\') {\n            this.maintainFocus(event);\n        }\n        else {\n            a11y_dialog_esm_focus(this.$el);\n        }\n        // Bind a focus event listener to the body element to make sure the focus\n        // stays trapped inside the dialog while open, and start listening for some\n        // specific key presses (TAB and ESC)\n        document.body.addEventListener(\'focus\', this.maintainFocus, true);\n        this.$el.addEventListener(\'keydown\', this.bindKeypress, true);\n        return this;\n    }\n    /**\n     * Hide the dialog element, restore the focus to the previously active\n     * element, stop listening for some specific key presses and fire all\n     * registered callbacks for `hide` event\n     */\n    hide(event) {\n        // If the dialog is already closed, abort\n        if (!this.shown)\n            return this;\n        // Dispatch a `hide` event\n        const hideEvent = this.fire(\'hide\', event);\n        // If the event was prevented, do not continue with the normal behavior\n        if (hideEvent.defaultPrevented)\n            return this;\n        this.shown = false;\n        this.$el.setAttribute(\'aria-hidden\', \'true\');\n        // Ensure the previously focused element (if any) has a `focus` method\n        // before attempting to call it to account for SVG elements\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/108\n        this.previouslyFocused?.focus?.();\n        // Remove the focus event listener to the body element and stop listening\n        // for specific key presses\n        document.body.removeEventListener(\'focus\', this.maintainFocus, true);\n        this.$el.removeEventListener(\'keydown\', this.bindKeypress, true);\n        return this;\n    }\n    /**\n     * Register a new callback for the given event type\n     */\n    on(type, handler, options) {\n        this.$el.addEventListener(type, handler, options);\n        return this;\n    }\n    /**\n     * Unregister an existing callback for the given event type\n     */\n    off(type, handler, options) {\n        this.$el.removeEventListener(type, handler, options);\n        return this;\n    }\n    /**\n     * Dispatch and return a custom event from the DOM element associated with\n     * this dialog; this allows authors to listen for and respond to the events\n     * in their own code\n     */\n    fire(type, event) {\n        const customEvent = new CustomEvent(type, {\n            detail: event,\n            cancelable: true,\n        });\n        this.$el.dispatchEvent(customEvent);\n        return customEvent;\n    }\n    /**\n     * Add a delegated event listener for when elememts that open or close the\n     * dialog are clicked, and call `show` or `hide`, respectively\n     */\n    handleTriggerClicks(event) {\n        // We need to retrieve the click target while accounting for Shadow DOM.\n        // When within a web component, `event.target` is the shadow root (e.g.\n        // `<my-dialog>`), so we need to use `event.composedPath()` to get the click\n        // target\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/582\n        const target = event.composedPath()[0];\n        const opener = closest(`[${SCOPE}-show="${this.id}"]`, target);\n        const explicitCloser = closest(`[${SCOPE}-hide="${this.id}"]`, target);\n        const implicitCloser = closest(`[${SCOPE}-hide]`, target) &&\n            closest(\'[aria-modal="true"]\', target) === this.$el;\n        // We use `closest(..)` (instead of `matches(..)`) so that clicking an\n        // element nested within a dialog opener does cause the dialog to open, and\n        // we use our custom `closest(..)` function so that it can cross shadow\n        // boundaries\n        // See: https://github.com/KittyGiraudel/a11y-dialog/issues/712\n        if (opener)\n            this.show(event);\n        if (explicitCloser || implicitCloser)\n            this.hide(event);\n    }\n    /**\n     * Private event handler used when listening to some specific key presses\n     * (namely ESC and TAB)\n     */\n    bindKeypress(event) {\n        // This is an escape hatch in case there are nested open dialogs, so that\n        // only the top most dialog gets interacted with (`closest` is basically\n        // `Element.prototype.closest()` accounting for Shadow DOM subtrees)\n        if (closest(\'[aria-modal="true"]\', getActiveEl()) !== this.$el) {\n            return;\n        }\n        let hasOpenPopover = false;\n        try {\n            hasOpenPopover = !!this.$el.querySelector(\'[popover]:not([popover="manual"]):popover-open\');\n        }\n        catch {\n            // Run that DOM query in a try/catch because not all browsers support the\n            // `:popover-open` selector, which would cause the whole expression to\n            // fail\n            // See: https://caniuse.com/mdn-css_selectors_popover-open\n            // See: https://github.com/KittyGiraudel/a11y-dialog/pull/578#discussion_r1343215149\n        }\n        // If the dialog is shown and the ESC key is pressed, prevent any further\n        // effects from the ESC key and hide the dialog, unless:\n        // - its role is `alertdialog`, which means it should be modal\n        // - or it contains an open popover, in which case ESC should close it\n        if (event.key === \'Escape\' &&\n            this.$el.getAttribute(\'role\') !== \'alertdialog\' &&\n            !hasOpenPopover) {\n            event.preventDefault();\n            this.hide(event);\n        }\n        // If the dialog is shown and the TAB key is pressed, make sure the focus\n        // stays trapped within the dialog element\n        if (event.key === \'Tab\') {\n            trapTabKey(this.$el, event);\n        }\n    }\n    /**\n     * If the dialog is shown and the focus is not within a dialog element (either\n     * this one or another one in case of nested dialogs) or attribute, move it\n     * back to the dialog container\n     * See: https://github.com/KittyGiraudel/a11y-dialog/issues/177\n     */\n    maintainFocus(event) {\n        const target = event.target;\n        if (!target.closest(`[aria-modal="true"], [${SCOPE}-ignore-focus-trap]`)) {\n            a11y_dialog_esm_focus(this.$el);\n        }\n    }\n}\n\nfunction instantiateDialogs() {\n    for (const el of document.querySelectorAll(\'[data-a11y-dialog]\')) {\n        new A11yDialog(el);\n    }\n}\nif (typeof document !== \'undefined\') {\n    if (document.readyState === \'loading\') {\n        document.addEventListener(\'DOMContentLoaded\', instantiateDialogs);\n    }\n    else {\n        instantiateDialogs();\n    }\n}\n\n\n\n;// ./data/actions.json\nconst actions_namespaceObject = /*#__PURE__*/JSON.parse(\'[{"id":"gbk","name":"Go Back","description":"Go back to the previous webpage","code":"window.history.back()"},{"id":"gfd","name":"Go Forward","description":"Go back to the previous webpage","code":"window.history.forward()"},{"id":"stt","name":"Scroll to Top","description":"Scroll to the top of the webpage","code":"window.scrollTo({ top: 0, behavior: \\\'smooth\\\' })"},{"id":"stb","name":"Scroll to Bottom","description":"Scroll to the bottom of the webpage","code":"window.scrollTo({ top: document.body.scrollHeight, behavior: \\\'smooth\\\' })"},{"id":"lnt","name":"Link in New Tab","description":"Open a link in a new tab","code":"window.open(params.url, \\\'_blank\\\')","params":["url"]},{"id":"tep","name":"Translate Page","description":"Translate the current webpage with service of your choice","code":"window.open(`https://translate.google.com/translate?sl=auto&tl=${params.language}&u=${encodeURIComponent(window.location.href)}`, \\\'_blank\\\')","params":["translator"]},{"id":"rlp","name":"Reload Page","description":"Reload the current webpage","code":"location.reload()"},{"id":"curl","name":"Copy URL","description":"Copy the current webpage URL to the clipboard","code":"navigator.clipboard.writeText(window.location.href)"},{"id":"cct","name":"Close Tab","description":"Close the current tab","code":"window.close()"},{"id":"ppg","name":"Print Page","description":"Print the current webpage","code":"window.print()"},{"id":"tfs","name":"Toggle Fullscreen","description":"Toggle fullscreen mode for the webpage","code":"document.documentElement.requestFullscreen()"},{"id":"cds","name":"Clear Data","description":"Clear the local storage/cookie of the webpage","code":"localStorage.clear();document.cookie = \\\'\\\'"},{"id":"atf","name":"Add to Favorites","description":"Add the current webpage to favorites/bookmarks","code":"window.external.AddFavorite(location.href, document.title)"}]\');\n;// ./js/components/navbar.js\nfunction navbar() {\n  var t = this;\n  t.n = document.querySelector(\'nav\');\n  t.close = function () {\n    document.body.style.overflow = \'auto\';\n    t.n.classList.remove(\'active\');\n  };\n  t.open = function () {\n    document.body.style.overflow = \'hidden\';\n    t.n.classList.add(\'active\');\n  };\n  if (t.n) {\n    document.querySelector(\'nav>button\').addEventListener(\'click\', () => {\n      console.log(\'toggleNav\');\n      if (t.n.classList.contains(\'active\')) t.close();else t.open();\n    });\n    document.querySelector(\'nav>.nav-overlay\').addEventListener(\'click\', () => {\n      t.close();\n    });\n    document.querySelectorAll(\'nav ul > a\').forEach(n => n.addEventListener(\'click\', () => {\n      t.close();\n    }));\n  }\n}\n;// ./js/components/themeManager.js\nfunction themeManager() {\n  //Theme Switcher\n  var toggles = document.getElementsByClassName(\'theme-toggle\');\n  if (window.CSS && CSS.supports(\'color\', \'var(--bg)\') && toggles) {\n    var storedTheme = localStorage.getItem(\'theme\') || (window.matchMedia(\'(prefers-color-scheme: dark)\').matches ? \'dark\' : \'light\');\n    if (storedTheme) document.documentElement.setAttribute(\'data-theme\', storedTheme);\n    for (var i = 0; i < toggles.length; i++) {\n      toggles[i].onclick = function () {\n        var currentTheme = document.documentElement.getAttribute(\'data-theme\');\n        var targetTheme = \'light\';\n        if (currentTheme === \'light\') {\n          targetTheme = \'dark\';\n        }\n        document.documentElement.setAttribute(\'data-theme\', targetTheme);\n        localStorage.setItem(\'theme\', targetTheme);\n      };\n    }\n  }\n}\n;// ./js/components/gotop.js\nfunction gotop() {\n  var el = this;\n  el.gt = document.getElementById(\'gt-link\');\n  el.scrollToTop = function () {\n    window.scroll({\n      top: 0,\n      left: 0,\n      behavior: \'smooth\'\n    });\n  };\n  el.listeners = function () {\n    window.addEventListener(\'scroll\', () => {\n      let y = window.scrollY;\n      if (y > 0) {\n        el.gt.classList.remove(\'hidden\');\n      } else {\n        el.gt.classList.add(\'hidden\');\n      }\n    });\n    el.gt.onclick = function (e) {\n      e.preventDefault();\n      if (document.documentElement.scrollTop || document.body.scrollTop > 0) {\n        el.scrollToTop();\n      }\n    };\n  };\n  if (el.gt) {\n    el.listeners();\n  }\n}\n;// ./js/components/aos.js\nfunction aos() {\n  //Get and observe all the items with the item class\n  let items = document.querySelectorAll(\'[class*=_aos]\');\n  //Only Use the IntersectionObserver if it is supported and _aos elements exist\n  if (IntersectionObserver && items) {\n    //When the element is visible on the viewport,\n    //add the _aos-done class so it creates the _aos animation.\n    let callback = function (entries) {\n      entries.forEach(entry => {\n        //if the element is visible, add the _aos-done class\n        if (entry.isIntersecting && !entry.target.classList.contains(\'_aos-done\')) {\n          entry.target.classList.add(\'_aos-done\');\n        } else {\n          //else the element do reverse animation\n          entry.target.classList.remove(\'_aos-done\');\n        }\n      });\n    };\n    //Create the observer\n    let observer = new IntersectionObserver(callback, {\n      root: null,\n      threshold: 0\n    });\n    //Add each _aos element to the observer\n    items.forEach(item => {\n      observer.observe(item);\n    });\n  }\n}\n;// ./js/components/snackbar.js\nfunction Snackbar(option) {\n  const t = this;\n  t.snack = document.createElement(\'div\');\n  t.snack.className = \'snackbar\';\n  t.message = document.createElement(\'div\');\n  t.snack.appendChild(t.message);\n  document.body.appendChild(t.snack);\n  t.top = option.topPos;\n  t.classNames = option.classNames;\n  t.autoClose = typeof option.autoClose === \'boolean\' ? option.autoClose : false;\n  t.autoCloseTimeout = option.autoClose && typeof option.autoCloseTimeout === \'number\' ? option.autoCloseTimeout : 3000;\n\n  //Methods\n  t.reset = function () {\n    t.message.innerHTML = \'\';\n    t.snack.classList.remove(t.classNames);\n  };\n  t.show = function (msg, type) {\n    t.hide();\n    t.message.innerHTML = msg;\n    t.snack.style.top = t.top;\n    t.snack.classList.add(type || t.classNames);\n    if (t.autoClose) {\n      setTimeout(function () {\n        t.hide();\n      }, t.autoCloseTimeout);\n    }\n  };\n  t.hide = function () {\n    t.snack.style.top = \'-100%\';\n    t.reset();\n  };\n}\n;// ./js/actions.js\n\n\n\n\n\n\n\n\n\n\nvar snackbar = new Snackbar({\n  topPos: \'10px\',\n  classNames: \'success\',\n  autoClose: true,\n  autoCloseTimeout: 2000\n});\nfunction fixURL(value) {\n  if (value.indexOf(\'https://\') < 0 && value.indexOf(\'http://\') < 0) return \'https://\' + value;\n  return value;\n}\nfunction copyToClip() {\n  var cssCode = document.getElementById(\'css-code\');\n  var range = document.createRange();\n  range.selectNode(cssCode);\n  window.getSelection().removeAllRanges();\n  window.getSelection().addRange(range);\n  document.execCommand(\'copy\');\n  window.getSelection().removeAllRanges();\n  snackbar.show(\'CSS copied to clipboard !\');\n}\n\n// Call the function when the DOM is loaded\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n  const dialog_support = new A11yDialog(document.querySelector(\'#dlg_support\'));\n  dialog_support.on(\'show\', () => document.documentElement.style.overflowY = \'hidden\');\n  dialog_support.on(\'hide\', () => document.documentElement.style.overflowY = \'\');\n  new themeManager();\n  new navbar();\n  new gotop();\n  new aos();\n\n  // Retrieve all input fields\n  const inputFields = document.querySelectorAll(\'.param-i\');\n  var codes = {};\n  for (let key in actions_namespaceObject) {\n    let value = actions_namespaceObject[key];\n    codes[value.id] = value.code;\n  }\n  // Add event listener to each input field\n  inputFields.forEach(input => {\n    input.addEventListener(\'input\', () => {\n      updateCode(input);\n    });\n  });\n  function updateCode(t) {\n    console.log(t.value);\n    const id = t.id.split(\'_\')[0];\n    // Get the input values for the parameters\n    var code_to_replace = codes[id];\n    var value = t.value;\n    console.log(code_to_replace);\n    // Construct the regular expression pattern dynamically\n    const pattern = new RegExp(`params.${t.id.split(\'_\')[1]}`, \'g\');\n    if (t.id.split(\'_\')[1] == \'url\') value = fixURL(value);\n    // Replace the pattern in the code snippet with the input value\n    const updatedCodeSnippet = code_to_replace.replace(pattern, t.value);\n    console.log(updatedCodeSnippet);\n\n    // Update the preview code element\n    const previewCode = document.getElementById(\'previewCode_\' + id);\n    if (previewCode) {\n      previewCode.textContent = updatedCodeSnippet;\n    }\n    Prism.highlightAll();\n  }\n});\n\n//# sourceURL=webpack:///./js/actions.js_+_7_modules?')},784:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/* PrismJS 1.29.0\nhttps://prismjs.com/download.html#themes=prism-okaidia&languages=markup+css+clike+javascript&plugins=line-numbers+normalize-whitespace+toolbar+copy-to-clipboard */\nvar _self = 'undefined' != typeof window ? window : 'undefined' != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {},\n  Prism = function (e) {\n    var n = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i,\n      t = 0,\n      r = {},\n      a = {\n        manual: e.Prism && e.Prism.manual,\n        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,\n        util: {\n          encode: function e(n) {\n            return n instanceof i ? new i(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n          },\n          type: function (e) {\n            return Object.prototype.toString.call(e).slice(8, -1);\n          },\n          objId: function (e) {\n            return e.__id || Object.defineProperty(e, '__id', {\n              value: ++t\n            }), e.__id;\n          },\n          clone: function e(n, t) {\n            var r, i;\n            switch (t = t || {}, a.util.type(n)) {\n              case 'Object':\n                if (i = a.util.objId(n), t[i]) return t[i];\n                for (var l in r = {}, t[i] = r, n) n.hasOwnProperty(l) && (r[l] = e(n[l], t));\n                return r;\n              case 'Array':\n                return i = a.util.objId(n), t[i] ? t[i] : (r = [], t[i] = r, n.forEach(function (n, a) {\n                  r[a] = e(n, t);\n                }), r);\n              default:\n                return n;\n            }\n          },\n          getLanguage: function (e) {\n            for (; e;) {\n              var t = n.exec(e.className);\n              if (t) return t[1].toLowerCase();\n              e = e.parentElement;\n            }\n            return 'none';\n          },\n          setLanguage: function (e, t) {\n            ;\n            e.className = e.className.replace(RegExp(n, 'gi'), ''), e.classList.add('language-' + t);\n          },\n          currentScript: function () {\n            if ('undefined' == typeof document) return null;\n            if ('currentScript' in document) return document.currentScript;\n            try {\n              throw new Error();\n            } catch (r) {\n              var e = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(r.stack) || [])[1];\n              if (e) {\n                var n = document.getElementsByTagName('script');\n                for (var t in n) if (n[t].src == e) return n[t];\n              }\n              return null;\n            }\n          },\n          isActive: function (e, n, t) {\n            for (var r = 'no-' + n; e;) {\n              var a = e.classList;\n              if (a.contains(n)) return !0;\n              if (a.contains(r)) return !1;\n              e = e.parentElement;\n            }\n            return !!t;\n          }\n        },\n        languages: {\n          plain: r,\n          plaintext: r,\n          text: r,\n          txt: r,\n          extend: function (e, n) {\n            var t = a.util.clone(a.languages[e]);\n            for (var r in n) t[r] = n[r];\n            return t;\n          },\n          insertBefore: function (e, n, t, r) {\n            var i = (r = r || a.languages)[e],\n              l = {};\n            for (var o in i) if (i.hasOwnProperty(o)) {\n              if (o == n) for (var s in t) t.hasOwnProperty(s) && (l[s] = t[s]);\n              t.hasOwnProperty(o) || (l[o] = i[o]);\n            }\n            var u = r[e];\n            return r[e] = l, a.languages.DFS(a.languages, function (n, t) {\n              t === u && n != e && (this[n] = l);\n            }), l;\n          },\n          DFS: function e(n, t, r, i) {\n            i = i || {};\n            var l = a.util.objId;\n            for (var o in n) if (n.hasOwnProperty(o)) {\n              t.call(n, o, n[o], r || o);\n              var s = n[o],\n                u = a.util.type(s);\n              'Object' !== u || i[l(s)] ? 'Array' !== u || i[l(s)] || (i[l(s)] = !0, e(s, t, o, i)) : (i[l(s)] = !0, e(s, t, null, i));\n            }\n          }\n        },\n        plugins: {},\n        highlightAll: function (e, n) {\n          a.highlightAllUnder(document, e, n);\n        },\n        highlightAllUnder: function (e, n, t) {\n          var r = {\n            callback: t,\n            container: e,\n            selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n          };\n          a.hooks.run('before-highlightall', r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), a.hooks.run('before-all-elements-highlight', r);\n          for (var i, l = 0; i = r.elements[l++];) a.highlightElement(i, !0 === n, r.callback);\n        },\n        highlightElement: function (n, t, r) {\n          var i = a.util.getLanguage(n),\n            l = a.languages[i];\n          a.util.setLanguage(n, i);\n          var o = n.parentElement;\n          o && 'pre' === o.nodeName.toLowerCase() && a.util.setLanguage(o, i);\n          var s = {\n            element: n,\n            language: i,\n            grammar: l,\n            code: n.textContent\n          };\n          function u(e) {\n            ;\n            s.highlightedCode = e, a.hooks.run('before-insert', s), s.element.innerHTML = s.highlightedCode, a.hooks.run('after-highlight', s), a.hooks.run('complete', s), r && r.call(s.element);\n          }\n          if (a.hooks.run('before-sanity-check', s), (o = s.element.parentElement) && 'pre' === o.nodeName.toLowerCase() && !o.hasAttribute('tabindex') && o.setAttribute('tabindex', '0'), !s.code) return a.hooks.run('complete', s), void (r && r.call(s.element));\n          if (a.hooks.run('before-highlight', s), s.grammar) {\n            if (t && e.Worker) {\n              var c = new Worker(a.filename);\n              c.onmessage = function (e) {\n                u(e.data);\n              }, c.postMessage(JSON.stringify({\n                language: s.language,\n                code: s.code,\n                immediateClose: !0\n              }));\n            } else u(a.highlight(s.code, s.grammar, s.language));\n          } else u(a.util.encode(s.code));\n        },\n        highlight: function (e, n, t) {\n          var r = {\n            code: e,\n            grammar: n,\n            language: t\n          };\n          if (a.hooks.run('before-tokenize', r), !r.grammar) throw new Error('The language \"' + r.language + '\" has no grammar.');\n          return r.tokens = a.tokenize(r.code, r.grammar), a.hooks.run('after-tokenize', r), i.stringify(a.util.encode(r.tokens), r.language);\n        },\n        tokenize: function (e, n) {\n          var t = n.rest;\n          if (t) {\n            for (var r in t) n[r] = t[r];\n            delete n.rest;\n          }\n          var a = new s();\n          return u(a, a.head, e), o(e, a, n, a.head, 0), function (e) {\n            for (var n = [], t = e.head.next; t !== e.tail;) n.push(t.value), t = t.next;\n            return n;\n          }(a);\n        },\n        hooks: {\n          all: {},\n          add: function (e, n) {\n            var t = a.hooks.all;\n            t[e] = t[e] || [], t[e].push(n);\n          },\n          run: function (e, n) {\n            var t = a.hooks.all[e];\n            if (t && t.length) for (var r, i = 0; r = t[i++];) r(n);\n          }\n        },\n        Token: i\n      };\n    function i(e, n, t, r) {\n      ;\n      this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || '').length;\n    }\n    function l(e, n, t, r) {\n      e.lastIndex = n;\n      var a = e.exec(t);\n      if (a && r && a[1]) {\n        var i = a[1].length;\n        a.index += i, a[0] = a[0].slice(i);\n      }\n      return a;\n    }\n    function o(e, n, t, r, s, g) {\n      for (var f in t) if (t.hasOwnProperty(f) && t[f]) {\n        var h = t[f];\n        h = Array.isArray(h) ? h : [h];\n        for (var d = 0; d < h.length; ++d) {\n          if (g && g.cause == f + ',' + d) return;\n          var v = h[d],\n            p = v.inside,\n            m = !!v.lookbehind,\n            y = !!v.greedy,\n            k = v.alias;\n          if (y && !v.pattern.global) {\n            var x = v.pattern.toString().match(/[imsuy]*$/)[0];\n            v.pattern = RegExp(v.pattern.source, x + 'g');\n          }\n          for (var b = v.pattern || v, w = r.next, A = s; w !== n.tail && !(g && A >= g.reach); A += w.value.length, w = w.next) {\n            var E = w.value;\n            if (n.length > e.length) return;\n            if (!(E instanceof i)) {\n              var P,\n                L = 1;\n              if (y) {\n                if (!(P = l(b, A, e, m)) || P.index >= e.length) break;\n                var S = P.index,\n                  O = P.index + P[0].length,\n                  j = A;\n                for (j += w.value.length; S >= j;) j += (w = w.next).value.length;\n                if (A = j -= w.value.length, w.value instanceof i) continue;\n                for (var C = w; C !== n.tail && (j < O || 'string' == typeof C.value); C = C.next) L++, j += C.value.length;\n                L--, E = e.slice(A, j), P.index -= A;\n              } else if (!(P = l(b, 0, E, m))) continue;\n              S = P.index;\n              var N = P[0],\n                _ = E.slice(0, S),\n                M = E.slice(S + N.length),\n                W = A + E.length;\n              g && W > g.reach && (g.reach = W);\n              var z = w.prev;\n              if (_ && (z = u(n, z, _), A += _.length), c(n, z, L), w = u(n, z, new i(f, p ? a.tokenize(N, p) : N, k, N)), M && u(n, w, M), L > 1) {\n                var I = {\n                  cause: f + ',' + d,\n                  reach: W\n                };\n                o(e, n, t, w.prev, A, I), g && I.reach > g.reach && (g.reach = I.reach);\n              }\n            }\n          }\n        }\n      }\n    }\n    function s() {\n      var e = {\n          value: null,\n          prev: null,\n          next: null\n        },\n        n = {\n          value: null,\n          prev: e,\n          next: null\n        };\n      e.next = n, this.head = e, this.tail = n, this.length = 0;\n    }\n    function u(e, n, t) {\n      var r = n.next,\n        a = {\n          value: t,\n          prev: n,\n          next: r\n        };\n      return n.next = a, r.prev = a, e.length++, a;\n    }\n    function c(e, n, t) {\n      for (var r = n.next, a = 0; a < t && r !== e.tail; a++) r = r.next;\n      n.next = r, r.prev = n, e.length -= a;\n    }\n    if (e.Prism = a, i.stringify = function e(n, t) {\n      if ('string' == typeof n) return n;\n      if (Array.isArray(n)) {\n        var r = '';\n        return n.forEach(function (n) {\n          r += e(n, t);\n        }), r;\n      }\n      var i = {\n          type: n.type,\n          content: e(n.content, t),\n          tag: 'span',\n          classes: ['token', n.type],\n          attributes: {},\n          language: t\n        },\n        l = n.alias;\n      l && (Array.isArray(l) ? Array.prototype.push.apply(i.classes, l) : i.classes.push(l)), a.hooks.run('wrap', i);\n      var o = '';\n      for (var s in i.attributes) o += ' ' + s + '=\"' + (i.attributes[s] || '').replace(/\"/g, '&quot;') + '\"';\n      return '<' + i.tag + ' class=\"' + i.classes.join(' ') + '\"' + o + '>' + i.content + '</' + i.tag + '>';\n    }, !e.document) return e.addEventListener ? (a.disableWorkerMessageHandler || e.addEventListener('message', function (n) {\n      var t = JSON.parse(n.data),\n        r = t.language,\n        i = t.code,\n        l = t.immediateClose;\n      e.postMessage(a.highlight(i, a.languages[r], r)), l && e.close();\n    }, !1), a) : a;\n    var g = a.util.currentScript();\n    function f() {\n      a.manual || a.highlightAll();\n    }\n    if (g && (a.filename = g.src, g.hasAttribute('data-manual') && (a.manual = !0)), !a.manual) {\n      var h = document.readyState;\n      'loading' === h || 'interactive' === h && g && g.defer ? document.addEventListener('DOMContentLoaded', f) : window.requestAnimationFrame ? window.requestAnimationFrame(f) : window.setTimeout(f, 16);\n    }\n    return a;\n  }(_self);\n true && module.exports && (module.exports = Prism), 'undefined' != typeof __webpack_require__.g && (__webpack_require__.g.Prism = Prism);\nPrism.languages.markup = {\n  comment: {\n    pattern: /\x3c!--(?:(?!\x3c!--)[\\s\\S])*?--\x3e/,\n    greedy: !0\n  },\n  prolog: {\n    pattern: /<\\?[\\s\\S]+?\\?>/,\n    greedy: !0\n  },\n  doctype: {\n    pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n    greedy: !0,\n    inside: {\n      'internal-subset': {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: !0,\n        greedy: !0,\n        inside: null\n      },\n      string: {\n        pattern: /\"[^\"]*\"|'[^']*'/,\n        greedy: !0\n      },\n      punctuation: /^<!|>$|[[\\]]/,\n      'doctype-tag': /^DOCTYPE/i,\n      name: /[^\\s<>'\"]+/\n    }\n  },\n  cdata: {\n    pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n    greedy: !0\n  },\n  tag: {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: !0,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[^\\s>\\/:]+:/\n        }\n      },\n      'special-attr': [],\n      'attr-value': {\n        pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n        inside: {\n          punctuation: [{\n            pattern: /^=/,\n            alias: 'attr-equals'\n          }, {\n            pattern: /^(\\s*)[\"']|[\"']$/,\n            lookbehind: !0\n          }]\n        }\n      },\n      punctuation: /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          namespace: /^[^\\s>\\/:]+:/\n        }\n      }\n    }\n  },\n  entity: [{\n    pattern: /&[\\da-z]{1,8};/i,\n    alias: 'named-entity'\n  }, /&#x?[\\da-f]{1,8};/i]\n}, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside['internal-subset'].inside = Prism.languages.markup, Prism.hooks.add('wrap', function (a) {\n  'entity' === a.type && (a.attributes.title = a.content.replace(/&amp;/, '&'));\n}), Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n  value: function (a, e) {\n    var s = {};\n    s['language-' + e] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: !0,\n      inside: Prism.languages[e]\n    }, s.cdata = /^<!\\[CDATA\\[|\\]\\]>$/i;\n    var t = {\n      'included-cdata': {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: s\n      }\n    };\n    t['language-' + e] = {\n      pattern: /[\\s\\S]+/,\n      inside: Prism.languages[e]\n    };\n    var n = {};\n    n[a] = {\n      pattern: RegExp('(<__[^>]*>)(?:<!\\\\[CDATA\\\\[(?:[^\\\\]]|\\\\](?!\\\\]>))*\\\\]\\\\]>|(?!<!\\\\[CDATA\\\\[)[^])*?(?=</__>)'.replace(/__/g, function () {\n        return a;\n      }), 'i'),\n      lookbehind: !0,\n      greedy: !0,\n      inside: t\n    }, Prism.languages.insertBefore('markup', 'cdata', n);\n  }\n}), Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n  value: function (a, e) {\n    Prism.languages.markup.tag.inside['special-attr'].push({\n      pattern: RegExp('(^|[\"\\'\\\\s])(?:' + a + ')\\\\s*=\\\\s*(?:\"[^\"]*\"|\\'[^\\']*\\'|[^\\\\s\\'\">=]+(?=[\\\\s>]))', 'i'),\n      lookbehind: !0,\n      inside: {\n        'attr-name': /^[^\\s=]+/,\n        'attr-value': {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            value: {\n              pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: !0,\n              alias: [e, 'language-' + e],\n              inside: Prism.languages[e]\n            },\n            punctuation: [{\n              pattern: /^=/,\n              alias: 'attr-equals'\n            }, /\"|'/]\n          }\n        }\n      }\n    });\n  }\n}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend('markup', {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;\n!function (s) {\n  var e = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n  s.languages.css = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\//,\n    atrule: {\n      pattern: RegExp('@[\\\\w-](?:[^;{\\\\s\"\\']|\\\\s+(?!\\\\s)|' + e.source + ')*?(?:;|(?=\\\\s*\\\\{))'),\n      inside: {\n        rule: /^@[\\w-]+/,\n        'selector-function-argument': {\n          pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: !0,\n          alias: 'selector'\n        },\n        keyword: {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: !0\n        }\n      }\n    },\n    url: {\n      pattern: RegExp('\\\\burl\\\\((?:' + e.source + '|(?:[^\\\\\\\\\\r\\n()\"\\']|\\\\\\\\[^])*)\\\\)', 'i'),\n      greedy: !0,\n      inside: {\n        function: /^url/i,\n        punctuation: /^\\(|\\)$/,\n        string: {\n          pattern: RegExp('^' + e.source + '$'),\n          alias: 'url'\n        }\n      }\n    },\n    selector: {\n      pattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + e.source + ')*(?=\\\\s*\\\\{)'),\n      lookbehind: !0\n    },\n    string: {\n      pattern: e,\n      greedy: !0\n    },\n    property: {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: !0\n    },\n    important: /!important\\b/i,\n    function: {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: !0\n    },\n    punctuation: /[(){};:,]/\n  }, s.languages.css.atrule.inside.rest = s.languages.css;\n  var t = s.languages.markup;\n  t && (t.tag.addInlined('style', 'css'), t.tag.addAttribute('style', 'css'));\n}(Prism);\nPrism.languages.clike = {\n  comment: [{\n    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: !0,\n    greedy: !0\n  }],\n  string: {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0\n  },\n  'class-name': {\n    pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: !0,\n    inside: {\n      punctuation: /[.\\\\]/\n    }\n  },\n  keyword: /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n  boolean: /\\b(?:false|true)\\b/,\n  function: /\\b\\w+(?=\\()/,\n  number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  operator: /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  punctuation: /[{}[\\];(),.:]/\n};\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  'class-name': [Prism.languages.clike['class-name'], {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n    lookbehind: !0\n  }],\n  keyword: [{\n    pattern: /((?:^|\\})\\s*)catch\\b/,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n    lookbehind: !0\n  }],\n  function: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  number: {\n    pattern: RegExp('(^|[^\\\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\\\dA-Fa-f]+(?:_[\\\\dA-Fa-f]+)*n?|\\\\d+(?:_\\\\d+)*n|(?:\\\\d+(?:_\\\\d+)*(?:\\\\.(?:\\\\d+(?:_\\\\d+)*)?)?|\\\\.\\\\d+(?:_\\\\d+)*)(?:[Ee][+-]?\\\\d+(?:_\\\\d+)*)?)(?![\\\\w$])'),\n    lookbehind: !0\n  },\n  operator: /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n}), Prism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/, Prism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern: RegExp('((?:^|[^$\\\\w\\\\xA0-\\\\uFFFF.\"\\'\\\\])\\\\s]|\\\\b(?:return|yield))\\\\s*)/(?:(?:\\\\[(?:[^\\\\]\\\\\\\\\\r\\n]|\\\\\\\\.)*\\\\]|\\\\\\\\.|[^/\\\\\\\\\\\\[\\r\\n])+/[dgimyus]{0,7}|(?:\\\\[(?:[^[\\\\]\\\\\\\\\\r\\n]|\\\\\\\\.|\\\\[(?:[^[\\\\]\\\\\\\\\\r\\n]|\\\\\\\\.|\\\\[(?:[^[\\\\]\\\\\\\\\\r\\n]|\\\\\\\\.)*\\\\])*\\\\])*\\\\]|\\\\\\\\.|[^/\\\\\\\\\\\\[\\r\\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\\\s|/\\\\*(?:[^*]|\\\\*(?!/))*\\\\*/)*(?:$|[\\r\\n,.;:})\\\\]]|//))'),\n    lookbehind: !0,\n    greedy: !0,\n    inside: {\n      'regex-source': {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: !0,\n        alias: 'language-regex',\n        inside: Prism.languages.regex\n      },\n      'regex-delimiter': /^\\/|\\/$/,\n      'regex-flags': /^[a-z]+$/\n    }\n  },\n  'function-variable': {\n    pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: 'function'\n  },\n  parameter: [{\n    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }],\n  constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n}), Prism.languages.insertBefore('javascript', 'string', {\n  hashbang: {\n    pattern: /^#!.*/,\n    greedy: !0,\n    alias: 'comment'\n  },\n  'template-string': {\n    pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: !0,\n    inside: {\n      'template-punctuation': {\n        pattern: /^`|`$/,\n        alias: 'string'\n      },\n      interpolation: {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: !0,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          rest: Prism.languages.javascript\n        }\n      },\n      string: /[\\s\\S]+/\n    }\n  },\n  'string-property': {\n    pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n    lookbehind: !0,\n    greedy: !0,\n    alias: 'property'\n  }\n}), Prism.languages.insertBefore('javascript', 'operator', {\n  'literal-property': {\n    pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n    lookbehind: !0,\n    alias: 'property'\n  }\n}), Prism.languages.markup && (Prism.languages.markup.tag.addInlined('script', 'javascript'), Prism.languages.markup.tag.addAttribute('on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)', 'javascript')), Prism.languages.js = Prism.languages.javascript;\n!function () {\n  if ('undefined' != typeof Prism && 'undefined' != typeof document) {\n    var e = 'line-numbers',\n      n = /\\n(?!$)/g,\n      t = Prism.plugins.lineNumbers = {\n        getLine: function (n, t) {\n          if ('PRE' === n.tagName && n.classList.contains(e)) {\n            var i = n.querySelector('.line-numbers-rows');\n            if (i) {\n              var r = parseInt(n.getAttribute('data-start'), 10) || 1,\n                s = r + (i.children.length - 1);\n              t < r && (t = r), t > s && (t = s);\n              var l = t - r;\n              return i.children[l];\n            }\n          }\n        },\n        resize: function (e) {\n          r([e]);\n        },\n        assumeViewportIndependence: !0\n      },\n      i = void 0;\n    window.addEventListener('resize', function () {\n      ;\n      t.assumeViewportIndependence && i === window.innerWidth || (i = window.innerWidth, r(Array.prototype.slice.call(document.querySelectorAll('pre.line-numbers'))));\n    }), Prism.hooks.add('complete', function (t) {\n      if (t.code) {\n        var i = t.element,\n          s = i.parentNode;\n        if (s && /pre/i.test(s.nodeName) && !i.querySelector('.line-numbers-rows') && Prism.util.isActive(i, e)) {\n          i.classList.remove(e), s.classList.add(e);\n          var l,\n            o = t.code.match(n),\n            a = o ? o.length + 1 : 1,\n            u = new Array(a + 1).join('<span></span>');\n          (l = document.createElement('span')).setAttribute('aria-hidden', 'true'), l.className = 'line-numbers-rows', l.innerHTML = u, s.hasAttribute('data-start') && (s.style.counterReset = 'linenumber ' + (parseInt(s.getAttribute('data-start'), 10) - 1)), t.element.appendChild(l), r([s]), Prism.hooks.run('line-numbers', t);\n        }\n      }\n    }), Prism.hooks.add('line-numbers', function (e) {\n      ;\n      e.plugins = e.plugins || {}, e.plugins.lineNumbers = !0;\n    });\n  }\n  function r(e) {\n    if (0 != (e = e.filter(function (e) {\n      var n,\n        t = (n = e, n ? window.getComputedStyle ? getComputedStyle(n) : n.currentStyle || null : null)['white-space'];\n      return 'pre-wrap' === t || 'pre-line' === t;\n    })).length) {\n      var t = e.map(function (e) {\n        var t = e.querySelector('code'),\n          i = e.querySelector('.line-numbers-rows');\n        if (t && i) {\n          var r = e.querySelector('.line-numbers-sizer'),\n            s = t.textContent.split(n);\n          r || ((r = document.createElement('span')).className = 'line-numbers-sizer', t.appendChild(r)), r.innerHTML = '0', r.style.display = 'block';\n          var l = r.getBoundingClientRect().height;\n          return r.innerHTML = '', {\n            element: e,\n            lines: s,\n            lineHeights: [],\n            oneLinerHeight: l,\n            sizer: r\n          };\n        }\n      }).filter(Boolean);\n      t.forEach(function (e) {\n        var n = e.sizer,\n          t = e.lines,\n          i = e.lineHeights,\n          r = e.oneLinerHeight;\n        i[t.length - 1] = void 0, t.forEach(function (e, t) {\n          if (e && e.length > 1) {\n            var s = n.appendChild(document.createElement('span'));\n            s.style.display = 'block', s.textContent = e;\n          } else i[t] = r;\n        });\n      }), t.forEach(function (e) {\n        for (var n = e.sizer, t = e.lineHeights, i = 0, r = 0; r < t.length; r++) void 0 === t[r] && (t[r] = n.children[i++].getBoundingClientRect().height);\n      }), t.forEach(function (e) {\n        var n = e.sizer,\n          t = e.element.querySelector('.line-numbers-rows');\n        n.style.display = 'none', n.innerHTML = '', e.lineHeights.forEach(function (e, n) {\n          t.children[n].style.height = e + 'px';\n        });\n      });\n    }\n  }\n}();\n!function () {\n  if ('undefined' != typeof Prism) {\n    var e = Object.assign || function (e, t) {\n        for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n        return e;\n      },\n      t = {\n        'remove-trailing': 'boolean',\n        'remove-indent': 'boolean',\n        'left-trim': 'boolean',\n        'right-trim': 'boolean',\n        'break-lines': 'number',\n        indent: 'number',\n        'remove-initial-line-feed': 'boolean',\n        'tabs-to-spaces': 'number',\n        'spaces-to-tabs': 'number'\n      };\n    n.prototype = {\n      setDefaults: function (t) {\n        this.defaults = e(this.defaults, t);\n      },\n      normalize: function (t, n) {\n        for (var r in n = e(this.defaults, n)) {\n          var i = r.replace(/-(\\w)/g, function (e, t) {\n            return t.toUpperCase();\n          });\n          'normalize' !== r && 'setDefaults' !== i && n[r] && this[i] && (t = this[i].call(this, t, n[r]));\n        }\n        return t;\n      },\n      leftTrim: function (e) {\n        return e.replace(/^\\s+/, '');\n      },\n      rightTrim: function (e) {\n        return e.replace(/\\s+$/, '');\n      },\n      tabsToSpaces: function (e, t) {\n        return t = 0 | t || 4, e.replace(/\\t/g, new Array(++t).join(' '));\n      },\n      spacesToTabs: function (e, t) {\n        return t = 0 | t || 4, e.replace(RegExp(' {' + t + '}', 'g'), '\\t');\n      },\n      removeTrailing: function (e) {\n        return e.replace(/\\s*?$/gm, '');\n      },\n      removeInitialLineFeed: function (e) {\n        return e.replace(/^(?:\\r?\\n|\\r)/, '');\n      },\n      removeIndent: function (e) {\n        var t = e.match(/^[^\\S\\n\\r]*(?=\\S)/gm);\n        return t && t[0].length ? (t.sort(function (e, t) {\n          return e.length - t.length;\n        }), t[0].length ? e.replace(RegExp('^' + t[0], 'gm'), '') : e) : e;\n      },\n      indent: function (e, t) {\n        return e.replace(/^[^\\S\\n\\r]*(?=\\S)/gm, new Array(++t).join('\\t') + '$&');\n      },\n      breakLines: function (e, t) {\n        t = !0 === t ? 80 : 0 | t || 80;\n        for (var n = e.split('\\n'), i = 0; i < n.length; ++i) if (!(r(n[i]) <= t)) {\n          for (var o = n[i].split(/(\\s+)/g), a = 0, l = 0; l < o.length; ++l) {\n            var s = r(o[l]);\n            (a += s) > t && (o[l] = '\\n' + o[l], a = s);\n          }\n          n[i] = o.join('');\n        }\n        return n.join('\\n');\n      }\n    },  true && module.exports && (module.exports = n), Prism.plugins.NormalizeWhitespace = new n({\n      'remove-trailing': !0,\n      'remove-indent': !0,\n      'left-trim': !0,\n      'right-trim': !0\n    }), Prism.hooks.add('before-sanity-check', function (e) {\n      var n = Prism.plugins.NormalizeWhitespace;\n      if ((!e.settings || !1 !== e.settings['whitespace-normalization']) && Prism.util.isActive(e.element, 'whitespace-normalization', !0)) if (e.element && e.element.parentNode || !e.code) {\n        var r = e.element.parentNode;\n        if (e.code && r && 'pre' === r.nodeName.toLowerCase()) {\n          for (var i in null == e.settings && (e.settings = {}), t) if (Object.hasOwnProperty.call(t, i)) {\n            var o = t[i];\n            if (r.hasAttribute('data-' + i)) try {\n              var a = JSON.parse(r.getAttribute('data-' + i) || 'true');\n              typeof a === o && (e.settings[i] = a);\n            } catch (e) {}\n          }\n          for (var l = r.childNodes, s = '', c = '', u = !1, m = 0; m < l.length; ++m) {\n            var f = l[m];\n            f == e.element ? u = !0 : '#text' === f.nodeName && (u ? c += f.nodeValue : s += f.nodeValue, r.removeChild(f), --m);\n          }\n          if (e.element.children.length && Prism.plugins.KeepMarkup) {\n            var d = s + e.element.innerHTML + c;\n            e.element.innerHTML = n.normalize(d, e.settings), e.code = e.element.textContent;\n          } else e.code = s + e.code + c, e.code = n.normalize(e.code, e.settings);\n        }\n      } else e.code = n.normalize(e.code, e.settings);\n    });\n  }\n  function n(t) {\n    this.defaults = e({}, t);\n  }\n  function r(e) {\n    for (var t = 0, n = 0; n < e.length; ++n) e.charCodeAt(n) == '\\t'.charCodeAt(0) && (t += 3);\n    return e.length + t;\n  }\n}();\n!function () {\n  if ('undefined' != typeof Prism && 'undefined' != typeof document) {\n    var e = [],\n      t = {},\n      n = function () {};\n    Prism.plugins.toolbar = {};\n    var a = Prism.plugins.toolbar.registerButton = function (n, a) {\n        var r;\n        r = 'function' == typeof a ? a : function (e) {\n          var t;\n          return 'function' == typeof a.onClick ? ((t = document.createElement('button')).type = 'button', t.addEventListener('click', function () {\n            a.onClick.call(this, e);\n          })) : 'string' == typeof a.url ? (t = document.createElement('a')).href = a.url : t = document.createElement('span'), a.className && t.classList.add(a.className), t.textContent = a.text, t;\n        }, n in t ? console.warn('There is a button with the key \"' + n + '\" registered already.') : e.push(t[n] = r);\n      },\n      r = Prism.plugins.toolbar.hook = function (a) {\n        var r = a.element.parentNode;\n        if (r && /pre/i.test(r.nodeName) && !r.parentNode.classList.contains('code-toolbar')) {\n          var o = document.createElement('div');\n          o.classList.add('code-toolbar'), r.parentNode.insertBefore(o, r), o.appendChild(r);\n          var i = document.createElement('div');\n          i.classList.add('toolbar');\n          var l = e,\n            d = function (e) {\n              for (; e;) {\n                var t = e.getAttribute('data-toolbar-order');\n                if (null != t) return (t = t.trim()).length ? t.split(/\\s*,\\s*/g) : [];\n                e = e.parentElement;\n              }\n            }(a.element);\n          d && (l = d.map(function (e) {\n            return t[e] || n;\n          })), l.forEach(function (e) {\n            var t = e(a);\n            if (t) {\n              var n = document.createElement('div');\n              n.classList.add('toolbar-item'), n.appendChild(t), i.appendChild(n);\n            }\n          }), o.appendChild(i);\n        }\n      };\n    a('label', function (e) {\n      var t = e.element.parentNode;\n      if (t && /pre/i.test(t.nodeName) && t.hasAttribute('data-label')) {\n        var n,\n          a,\n          r = t.getAttribute('data-label');\n        try {\n          a = document.querySelector('template#' + r);\n        } catch (e) {}\n        return a ? n = a.content : (t.hasAttribute('data-url') ? (n = document.createElement('a')).href = t.getAttribute('data-url') : n = document.createElement('span'), n.textContent = r), n;\n      }\n    }), Prism.hooks.add('complete', r);\n  }\n}();\n!function () {\n  function t(t) {\n    var e = document.createElement('textarea');\n    e.value = t.getText(), e.style.top = '0', e.style.left = '0', e.style.position = 'fixed', document.body.appendChild(e), e.focus(), e.select();\n    try {\n      var o = document.execCommand('copy');\n      setTimeout(function () {\n        o ? t.success() : t.error();\n      }, 1);\n    } catch (e) {\n      setTimeout(function () {\n        t.error(e);\n      }, 1);\n    }\n    document.body.removeChild(e);\n  }\n  'undefined' != typeof Prism && 'undefined' != typeof document && (Prism.plugins.toolbar ? Prism.plugins.toolbar.registerButton('copy-to-clipboard', function (e) {\n    var o = e.element,\n      n = function (t) {\n        var e = {\n          copy: 'Copy',\n          'copy-error': 'Press Ctrl+C to copy',\n          'copy-success': 'Copied!',\n          'copy-timeout': 5e3\n        };\n        for (var o in e) {\n          for (var n = 'data-prismjs-' + o, c = t; c && !c.hasAttribute(n);) c = c.parentElement;\n          c && (e[o] = c.getAttribute(n));\n        }\n        return e;\n      }(o),\n      c = document.createElement('button');\n    c.className = 'copy-to-clipboard-button', c.setAttribute('type', 'button');\n    c.innerHTML = '<svg  xmlns=\"http://www.w3.org/2000/svg\"  width=\"24\"  height=\"24\"  viewBox=\"0 0 24 24\"  fill=\"none\"  stroke=\"currentColor\"  stroke-width=\"2\"  stroke-linecap=\"round\"  stroke-linejoin=\"round\"  class=\"icon icon-tabler icons-tabler-outline icon-tabler-copy\"><path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z\" /><path d=\"M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1\" /></svg>';\n    var r = document.createElement('span');\n    return c.appendChild(r), u('copy'), function (e, o) {\n      e.addEventListener('click', function () {\n        !function (e) {\n          navigator.clipboard ? navigator.clipboard.writeText(e.getText()).then(e.success, function () {\n            t(e);\n          }) : t(e);\n        }(o);\n      });\n    }(c, {\n      getText: function () {\n        return o.textContent;\n      },\n      success: function () {\n        u('copy-success'), i();\n      },\n      error: function () {\n        u('copy-error'), setTimeout(function () {\n          !function (t) {\n            window.getSelection().selectAllChildren(t);\n          }(o);\n        }, 1), i();\n      }\n    }), c;\n    function i() {\n      setTimeout(function () {\n        u('copy');\n      }, n['copy-timeout']);\n    }\n    function u(t) {\n      ;\n      r.textContent = n[t], c.setAttribute('data-copy-state', t);\n    }\n  }) : console.warn('Copy to Clipboard plugin loaded before Toolbar plugin.'));\n}();\n\n//# sourceURL=webpack:///./js/components/prism.min.js?")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__(551)})();